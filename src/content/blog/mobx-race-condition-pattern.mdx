---
title: "Critical Race Condition Pattern in MobX"
description: "Understanding and preventing a common bug where MobX store methods recreate observable objects, invalidating all previous references during async operations."
date: "2025-01-21"
tags: ["mobx", "react", "typescript", "debugging", "state management"]
published: true
---

# Critical Race Condition Pattern in MobX

When working with MobX stores in complex applications, there's a subtle but critical bug pattern that can cause hours of debugging frustration. This article explains the race condition that occurs when store methods recreate observable objects, and how to prevent it.

## The Problem

When store methods recreate observable objects (e.g., during hydration), all previous object references become invalid. This creates a race condition where async operations continue working with stale references.

<Callout type="warning" title="Symptoms">
  - Updates to objects fail silently after WebSocket events
  - State changes don't persist after concurrent operations
  - Loading states get stuck indefinitely
</Callout>

## Root Cause

Store methods like `hydrateState()` replace all observable instances. Any references held before that moment become stale — they point to objects that are no longer part of the store's state tree.

## The Bug Pattern

Here's what the problematic code looks like:

```typescript
public async updateSomething(id: string) {
    const obj = this.getObjectById(id); // Store reference
    obj.setLoading(true);

    const data = await this.api.fetch(id);
    // Meanwhile, WebSocket event calls hydration method
    // which recreates all objects - 'obj' is now stale!

    obj.updateData(data); // FAILS - operates on dead object
    obj.setLoading(false); // FAILS - operates on dead object
}
```

The timeline of this bug:

1. Method starts, gets reference to object
2. Sets loading state on the object
3. Starts async API call
4. **During the await**, a WebSocket event triggers `hydrateState()`
5. `hydrateState()` recreates all objects with fresh instances
6. Async call completes
7. Code tries to update the **old** object reference
8. Updates are lost because they're applied to a detached object

<Callout type="danger" title="Why This Is Dangerous">
  The bug is silent — no errors are thrown. The code executes successfully, but changes are made to objects that are no longer connected to the reactive state tree.
</Callout>

## The Solution

Always re-fetch objects by ID after any `await` call:

```typescript
public async updateSomething(id: string) {
    let obj = this.getObjectById(id);
    if (!obj) return;
    obj.setLoading(true);

    const data = await this.api.fetch(id);

    // Re-fetch object after async operation
    obj = this.getObjectById(id);
    if (obj) {
        obj.updateData(data); // Works - uses current object
        obj.setLoading(false); // Works - uses current object
    }
}
```

## Prevention Rules

Follow these rules to avoid this race condition:

1. **Never store object references across async operations**
2. **Always re-fetch by ID after `await` calls**
3. **Use ID-based lookups in async methods**

<Callout type="tip" title="Pro Tip">
  Create a linting rule or code review checklist item to catch stored references before `await` statements in MobX store methods.
</Callout>

## Real-World Scenario

This bug commonly appears in applications with:

- **WebSocket connections** that sync state from the server
- **SSR hydration** that recreates store state on the client
- **Polling mechanisms** that periodically refresh data
- **Optimistic updates** combined with server reconciliation

Any time your store has a method that bulk-replaces observable objects, you're at risk for this race condition.

## Testing for This Bug

To verify your code handles this correctly:

```typescript
it('should handle concurrent hydration during async operation', async () => {
    const store = new MyStore();
    const id = 'test-id';

    // Start async operation
    const updatePromise = store.updateSomething(id);

    // Simulate hydration during the async operation
    store.hydrateState();

    // Wait for async operation to complete
    await updatePromise;

    // Verify the update was applied to the current object
    const obj = store.getObjectById(id);
    expect(obj.data).toEqual(expectedData);
    expect(obj.isLoading).toBe(false);
});
```

---

Understanding this pattern will save you from mysterious bugs where state updates seem to disappear into thin air. Always remember: in MobX with async operations, **object references are temporary** — re-fetch after every await.
